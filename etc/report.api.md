## API Report File for "use-quantum-state"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Dispatch } from 'react';
import { ForwardedRef } from 'react';
import { PropsWithRef } from 'react';
import { ReactNode } from 'react';
import { SetStateAction } from 'react';

// @public
export type AccessorFn<T> = (x: T) => any;

// @public
export function createQuantumContext<T extends Obj | Obj[]>(defaultValue: T extends Obj ? T | null : T extends Obj[] ? T | null : never): [QuantumProvider<T>, QuantumStateHook<T>];

// @public
export function isCallable(fn: any): fn is (...args: any[]) => any;

// @public
export type Obj = Record<string, any>;

// @public
export interface QuantumEmitter<T> {
    emit(event: QuantumPath<T>, value: ValueAtPathStr<T, typeof event>): void;
    on(event: QuantumPath<T>, listener: (value: ValueAtPathStr<T, typeof event>) => void): Unsubscribe;
    once(event: QuantumPath<T>, listener: (value: ValueAtPathStr<T, typeof event>) => void): Unsubscribe;
}

// @public
export type QuantumPath<T> = T extends infer t extends Obj[] ? `${number}.${QuantumPath<t[number]>}` : T extends infer t extends Obj ? `${keyof t & string}` : '';

// @public
export type QuantumProvider<T extends Obj | Obj[]> = (props: PropsWithRef<QuantumProviderProps<T>>) => JSX.Element;

// @public
export interface QuantumProviderProps<T extends Obj | Obj[]> {
    // (undocumented)
    children: ReactNode;
    // (undocumented)
    ref?: ForwardedRef<QuantumEmitter<T>>;
    // (undocumented)
    value?: T;
}

// @public
export type QuantumStateHook<T extends Obj | Obj[]> = <P extends QuantumPath<T>>(pathOrAccessor: P | AccessorFn<T>) => QuantumStateHookReturn<T, P>;

// @public
export type QuantumStateHookReturn<T extends Obj | Obj[], P extends QuantumPath<T>> = [ValueAtPathStr<T, P>, Dispatch<SetStateAction<ValueAtPathStr<T, P>>>];

// @public
export type SplitString<S extends string> = S extends `${infer a}.${infer b}` ? [a, ...SplitString<b>] : [S];

// @public
export type Tail<T extends any[]> = T extends [infer _, ...infer rest] ? rest : [];

// @public
export type Unsubscribe = () => void;

// @public
export type ValueAtPath<T, P extends string[]> = P extends infer p extends [string] | [string, ...string[]] ? T extends {
    [K in p[0]]: infer U;
} ? ValueAtPath<U, Tail<p>> : never : P extends [] ? T : never;

// @public
export type ValueAtPathStr<T, P extends string> = ValueAtPath<T, SplitString<P>>;

```
